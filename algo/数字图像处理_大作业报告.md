#数字图像处理 大作业报告

####Introduction

本次大作业选择的论文是*Face Swapping: Automatically Replacing Faces in Photographs*，来自SIGGRAPH 08'。这篇论文的目标是实现人脸的“无缝”替换，但并不是替换成指定的目标人脸，而是在一个很大的图片库中进行筛选，选择“最适合替换”的人脸来进行替换。因此，这篇文章可以分为两部分，第一部分就是对图片库的建立和人脸筛选，第二部分是把人脸替换以后的后处理方法。因为这篇文章使用到很多比较复杂的图像处理技巧，尤其是需要用到复杂的公式，这些部分因为自己的能力不足，并没有用原始的方法实现，而是采用了实现简单，但是效果差一些的方法来进行替换。

下面我按照图片库的建立，人脸替换过程，图片库中人脸排序，以及后处理的过程来对自己的实现进行介绍。

####图片库的建立

因为我们的算法并没有对人脸采用3D模型的重建，因此控制**被替换人脸**和**替换人脸**之间的**角度关系**很重要。一张脸的角度可以用三个参数来表示：yaw, pitch和roll，其中yaw度量了脸的左右偏转的程度，pitch衡量的是抬头或者低头的程度，roll则是在人脸平面上的转动的衡量。如果我们用一张yaw和pitch相同的人脸来替换我们的目标人脸，那么在替换过程中，只需要在平面上进行偏转(in-plane)，操作起来很简单。

根据论文中的技术，我们这里把所有的人脸按照yaw和pitch两个维度来进行划分。这里pitch取-15到15之间，每个区间取10；yaw取-25到25之间，每个区间取10。因此我们现在在yaw上有5个区间，在pitch上有3个区间，因此我们把所有的图片库中的人脸划分成15个不同的**角度分类**(以下用posebin来指称)。

我的代码的大部分工作主要是集中在这个部分，下面我对建立流程进行一个概述：

1. 图片库建立的入口在`facetrain.py`中。该程序接受两个参数，一个是图片库的根目录，一个是把图片库导入的目标posebin的位置。我这里用到的图片库来自于LFW(Labeled Face in the Wild) Face Database，选用这个图片库的原因主要是该图片库提供很详细的人名标记数据，以及对齐过的人脸照片。对齐这个特性在之后替换的过程中很管用。
2. 程序首先遍历图片库的根目录，得到所有图片的路径。之后遍历这个列表，依次处理每张人脸照片。处理的过程大致如下：
    1. 用Face++人脸识别服务获得yaw，pitch，roll这几个角度(pose)参数，根据yaw和pitch来决定应该放在哪个posebin中
    2. 同时获得人脸的中心位置和人脸的范围，这里直接把人脸截取保存下来
    3. 最后也会获得一些人脸上的landmark的位置，比如人脸的轮廓，眼睛的轮廓等

到此位置图片库建立完成了，在指定的posebin路径下出现了15个posebin，以及一个编号为0的不满足条件的posebin。在posebin的目录下也保存有一个所有人脸的相关数据的数据文件。

这一部分的代码主要有：

1. `facetrain.py`：程序的入口
2. `faceposebin.py`：与posebin有关的处理
3. `faceinfo.py`：对脸部信息的转换
4. `faceproc.py`：对人脸的处理，主要是截取，保存到指定的posebin等等
5. `faceset.py`：对图片库的抽象，主要函数就是提取这个图片库中所有的图片路径

####人脸的替换

这里我们称**替换人脸**为从图片库中选出来的，换到我们的目标图片上的人脸；称**目标人脸**为要被替换的人脸。在不考虑替换人脸的选择、排序和后处理等机制时，我们先讨论一下如何把一张图片库中的脸换到指定的目标人脸的方法。第一步首先要把替换人脸提取出来，这里采用的方法如下：

1. **获得轮廓**：调用Face++的API，获得人脸的轮廓。注意这里并不是要获得整张脸的轮廓，而是包含关键的面部器官的区域。因此我们选择的轮廓线是从眉毛上方出发，向下到眼角的外侧，再到下嘴唇的外侧。
2. **修改轮廓**：考虑到Face++返回的landmark都是跟面部器官紧紧贴合的，这样在之后匹配时，如果目标人脸的器官过大(-_-)，比如眼睛很大等等，就可能覆盖不上。所以这里我们会对landmark的位置进行一下修改，方法是：从鼻子的位置出发，往这些landmark连线，然后对沿着这根线的角度扩展一下距离。这样得到的新的轮廓线可以保证是包裹在原先的轮廓线之上的。
3. **提取替换人脸**：提取的过程依然是基于轮廓线的。我们这里用的是Python OpenCV提供的库：`cv2.pointPolygonTest`可以获得一个点跟轮廓线的距离，如果为负的话则表示在轮廓线之外。根据这个判断条件，我们把判定为负的像素点都改为0
4. **仿射变换**：尽管我们已经得到了替换人脸，但是目标人脸跟替换人脸之间可能有如下两种不匹配的情况：**大小不相等**和**旋转角度不相等**，而这两种不匹配都可以用仿射变换(affine transform)来解决。要想进行仿射变换，首先是要得到变换矩阵。这个变换矩阵可以用三个从原图到目标图的点对，来解一个线性方程组得到。我们选用的点对是`左眼`、`右眼`和`鼻子`的位置。求转换矩阵的过程可以用OpenCV的`warpAffine`函数，执行affine transform可以用OpenCV的`getAffineTransform`函数。(之前我自己实现过一个affine transform的版本，但是因为效果不好放弃了……)

这部分的代码放在`misc`目录下：

1. `affine.py`：是自己实现的仿射变换函数
2. `contour.py`：提取轮廓线，以及脸部区域图片
3. `facealign.py`：得到替换的结果，中间使用了`contour.py`的函数，以及仿射变换

####候选人脸的排序

####后处理
